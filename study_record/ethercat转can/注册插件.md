# 注册插件

## 1. 什么是硬件接口插件？

在 **ros_control** 中，硬件接口插件（Hardware Interface Plugin）是一个 C++ 类，它：

- 继承自 `hardware_interface::RobotHW` 基类
- 负责**与真实硬件通信**（比如电机驱动器、传感器）
- 向 `controller_manager` 提供标准化的访问接口（位置、速度、力矩等）
- 在运行时被 `controller_manager` 周期性调用，以 `read()` 状态和 `write()` 指令

> 你可以把它理解为 **ros_control 与硬件之间的驱动层**。

## 2. 硬件接口类型

ros_control 提供了多种预定义的硬件接口基类，最常用的是：

| 接口类                                          | 用途               | 方向           |
| -------------------------------------------- | ---------------- | ------------ |
| `hardware_interface::JointStateInterface`    | 读取关节状态（位置、速度、力矩） | 输入（硬件 → 控制器） |
| `hardware_interface::PositionJointInterface` | 控制关节位置           | 输出（控制器 → 硬件） |
| `hardware_interface::VelocityJointInterface` | 控制关节速度           | 输出           |
| `hardware_interface::EffortJointInterface`   | 控制力 / 力矩         | 输出           |

## 3. 插件实现的必要部分

一个完整的硬件接口插件需要包含：

1. **类定义**：继承 `hardware_interface::RobotHW`
2. **成员变量**：
   - 状态变量（位置、速度、力矩）
   - 指令变量（位置、速度、力矩）
   - 接口实例
3. **构造函数**：注册接口
4. **`init()` 方法**：初始化硬件通信（串口、CAN、网口等）
5. **`read()` 方法**：从硬件读取状态
6. **`write()` 方法**：向硬件发送指令
7. **插件导出宏**：让 ROS 可以动态加载这个插件

```cpp
namespace controller_interface {
    template <class T>
    class Controller : public ControllerBase {
    public:
        virtual bool init(T* hw, ros::NodeHandle& root_nh, ros::NodeHandle& controller_nh) = 0;
        virtual void starting(const ros::Time& time) {}
        virtual void update(const ros::Time& time, const ros::Duration& period) = 0;
        virtual void stopping(const ros::Time& time) {}
    };
}
```

模板参数 `T` 代表**这个控制器要使用的硬件接口类型**，例如：

- `hardware_interface::PositionJointInterface`
- `hardware_interface::VelocityJointInterface`
- `hardware_interface::EffortJointInterface`

## `hardware_interface::PositionJointInterface`

- **作用**：控制器直接发送**关节位置指令**（单位：rad 或 m）
- **控制方式**：
  - 你告诉硬件 “关节要运动到某个位置”
  - 硬件层（电机驱动）需要自己做**位置闭环控制**（PID）
- **典型应用**：
  - 机械臂关节控制（目标角度）
  - 轮式机器人精确控制转动角度（里程控制）
- **优点**：
  - 使用简单，控制直观
- **缺点**：
  - 对速度和加速度没有直接限制，容易出现冲击
  - 需要硬件支持位置环

---

## 2. `hardware_interface::VelocityJointInterface`

- **作用**：控制器直接发送**关节速度指令**（单位：rad/s 或 m/s）
- **控制方式**：
  - 你告诉硬件 “关节以某个速度转动”
  - 硬件层做**速度闭环控制**
- **典型应用**：
  - 差速驱动机器人（控制轮子转速）
  - 需要平滑速度控制的关节
- **优点**：
  - 运动更平稳，可以精确控制速度
  - 比位置控制更容易避免机械冲击
- **缺点**：
  - 位置精度不如位置控制（需要上层做积分计算位置）
  - 长时间运行可能累积位置误差

---

## 3. `hardware_interface::EffortJointInterface`

- **作用**：控制器直接发送**关节力 / 力矩指令**（单位：N 或 N・m）
- **控制方式**：
  - 你告诉硬件 “关节输出某个力 / 力矩”
  - 硬件层通常做**电流控制**（力矩模式）
- **典型应用**：
  - 力控机器人（装配、抓取任务）
  - 柔顺控制（让机器人能和环境安全交互）
  - 需要精确力矩输出的场景
- **优点**：
  - 可以直接控制力，安全性好
  - 适合物理交互任务
- **缺点**：
  - 控制复杂，通常需要力矩传感器或精确模型
  - 没有直接的位置 / 速度限制，需上层控制算法保证稳定

## **1. 为什么控制节点要做成插件（Plugin）？**

在 ROS Control 里，**控制器（controller）** 是通过 **插件（pluginlib）** 机制加载的，而不是直接写死在 main () 里运行。

### 1.1 插件化的好处

- **动态加载 / 卸载**
  
  不需要重启机器人驱动，就能更换控制器（比如从速度控制切换到位置控制）

- **解耦**
  
  控制器代码和硬件驱动代码是分开的，硬件驱动只提供接口，控制器只关心算法

- **可扩展性强**
  
  你可以自己写一个新的控制器（比如模糊控制、滑模控制），编译成 `.so` 插件，ROS 就能识别并加载

- **复用性高**
  
  同一个控制器可以在不同机器人上运行，只要硬件接口一致

### 1.2 插件机制的原理

ROS Control 用 **`pluginlib`** 来管理控制器插件：

1. 控制器类继承自 `controller_interface::ControllerBase`
2. 在 `.cpp` 文件末尾用 `PLUGINLIB_EXPORT_CLASS` 宏注册插件
3. 在 `package.xml` 和 `.plugin` 文件中声明插件位置
4. `controller_manager` 启动时会根据配置文件（YAML）中指定的控制器类型，通过插件机制动态加载对应的类

---

## **2. 什么是 “注册到硬件抽象层的接口管理器”？**

在 ROS Control 中，硬件抽象层（HAL）的核心是 `hardware_interface::RobotHW` 类，它有一个**接口管理器（Interface Manager）**。

### 2.1 接口管理器的作用

- **统一管理所有硬件接口**
  
  包括 `JointStateInterface`、`PositionJointInterface`、`VelocityJointInterface`、`EffortJointInterface` 等

- **提供查询接口**
  
  控制器启动时会向接口管理器查询自己需要的接口类型

- **隔离硬件细节**
  
  控制器只通过接口管理器获取关节的状态和控制命令指针，不直接访问硬件

## **3. 底层逻辑流程**

### 3.1 启动阶段

1. **硬件驱动初始化**
   
   - 创建 `JointStateHandle`、`JointHandle`
   - 注册到对应的接口（`JointStateInterface`、`VelocityJointInterface` 等）
   - 调用 `registerInterface()` 把这些接口放到接口管理器中

2. **controller_manager 启动**
   
   - 加载 YAML 配置文件，知道要启动哪些控制器
   - 通过插件机制加载控制器类

3. **控制器初始化**
   
   - 控制器调用 `getHardwareInterface()` 从接口管理器获取所需接口
   - 保存关节的状态和命令变量指针

### 3.2 运行阶段

1. **读取状态（read ()）**
   
   - 硬件驱动从实际硬件读取数据（编码器、电流等）
   - 更新 `pos_`, `vel_`, `eff_` 等变量
   - 控制器通过状态接口读取这些值

2. **控制器计算**
   
   - 控制器根据目标值和当前状态计算出新的命令值
   - 写入命令变量（如 `cmd_vel_`）

3. **写入硬件（write ()）**
   
   - 硬件驱动读取命令变量
   - 发送到硬件（驱动器、电机等）

---

## 1️⃣ 使用 pluginlib 导出插件（C++）

### 核心步骤

1. **创建插件类** - 继承自插件接口
2. **注册插件** - 使用 PLUGINLIB_EXPORT_CLASS 宏
3. **创建插件描述文件** - XML 格式，描述插件信息
4. **CMakeLists 配置** - 编译插件并安装描述文件
5. **package.xml 声明** - 告诉 ROS 插件的存在

**插件实现文件**（my_plugin.cpp）：

```cpp
#include <pluginlib/class_list_macros.h>
#include "my_package/my_plugin_interface.h"

namespace my_package {
class MyPlugin : public MyPluginInterface {
public:
    void initialize() override {
        ROS_INFO("MyPlugin initialized");
    }
};
} // namespace my_package

// 注册插件
PLUGINLIB_EXPORT_CLASS(my_package::MyPlugin, my_package::MyPluginInterface)
```

## 1. 宏的作用总览

`PLUGINLIB_EXPORT_CLASS` 是 **pluginlib** 提供的一个 C++ 宏，它的作用是：

> 在编译生成的动态链接库（`.so` 文件）中，添加一些**元数据信息**，让 ROS 的 `pluginlib` 在运行时能够**找到并加载**你的插件类。

换句话说：

- 你写了一个插件类（比如 `MyPlugin`）

- 它实现了某个接口（比如 `MyPluginInterface`）

- 你用这个宏告诉 pluginlib：
  
  > “嘿，我这里有一个叫 `my_package::MyPlugin` 的类，它可以作为 `my_package::MyPluginInterface` 接口的一个实现，你可以在运行时加载我。”

---

## 2. 第一个参数：`my_package::MyPlugin`

- **含义**：这是你插件的**具体实现类**的**完整类型名**（带命名空间）。
- **作用**：
  1. 告诉宏要注册哪个类。
  2. 生成一个全局变量（实际上是一个 `pluginlib::ClassLoader` 能识别的工厂函数），用来在运行时创建这个类的实例。
- **要求**：
  - 必须是一个**具体类**（不能是纯虚类）。
  - 必须继承自第二个参数指定的基类 / 接口。
  - 必须有一个**默认构造函数**（无参数构造），因为 pluginlib 会用它来创建实例。

---

## 3. 第二个参数：`my_package::MyPluginInterface`

- **含义**：这是你的插件实现的 ** 基类（接口）** 的完整类型名。
- **作用**：
  1. 告诉 pluginlib 这个插件属于哪个 “接口家族”。
  2. 让 `pluginlib::ClassLoader<BaseClass>` 可以加载它。
  3. 在运行时，你会通过基类指针来使用插件，从而实现多态。
- **要求**：
- 通常是一个纯虚类（抽象接口），定义了插件必须实现的方法。
- 必须是可被动态_cast 的（有虚函数表）。
- 插件管理器（ClassLoader）就是用这个基类来管理不同的插件实现。

## 4. 宏的背后原理（简化版）

在编译预处理后，会展开成类似这样的代码：

```cpp
namespace pluginlib {
  template<>
  class ClassLoader<my_package::MyPluginInterface>::RegisterHelper<my_package::MyPlugin>
  {
  public:
    RegisterHelper() {
      ClassLoader<my_package::MyPluginInterface>::getPluginInfoMap()
        ["my_package::MyPlugin"] =
        boost::bind(&pluginlib::createInstance<my_package::MyPlugin>, _1);
    }
  };
  static RegisterHelper<my_package::MyPlugin> g_register_helper_instance;
}
```

**插件描述文件**（my_plugin.xml）：

```cpp
<library path="lib/libmy_plugin">
  <class name="my_package/MyPlugin" type="my_package::MyPlugin" 
         base_class_type="my_package::MyPluginInterface">
    <description>示例插件</description>
  </class>
</library>
```

## 1. `<library>` 标签

**作用**：

代表一个**动态链接库文件**（`.so` 文件），里面包含一个或多个插件类。

### `path` 属性

- **示例值**：`lib/libmy_plugin`
- **含义**：
  - 指定动态库文件的路径（相对于 package 安装路径）。
  - 注意：
    - 不需要写 `.so` 后缀（ROS 会自动补全）。
    - `lib/` 是 ROS 包默认的库安装目录（`CATKIN_PACKAGE_LIB_DESTINATION`）。
    - `libmy_plugin` 是你的 CMake `add_library(my_plugin ...)` 生成的库文件名。
- **作用**：
  - pluginlib 会根据这个路径找到并加载 `.so` 文件。
  - 然后才能从中找到你注册的插件类。

---

## 2. `<class>` 标签

**作用**：

描述动态库中的一个具体插件类。

### `name` 属性

- **示例值**：`my_package/MyPlugin`
- **含义**：
  - 插件的**唯一名称**（ROS 推荐格式是 `包名/类名`）。
  - 这个名字是给用户 / ROS 系统在查找插件时用的 “友好名称”。
- **作用**：
  - 你在代码中用 `ClassLoader::createInstance("my_package/MyPlugin")` 时，就是用这个名字来查找插件。
  - 必须全局唯一（至少在同一个基类接口的插件范围内唯一）。

---

### `type` 属性

- **示例值**：`my_package::MyPlugin`
- **含义**：
  - 插件类的**完整 C++ 类型名**（包含命名空间）。
  - 必须与你在 C++ 代码里用 `PLUGINLIB_EXPORT_CLASS` 注册的第一个参数完全一致。
- **作用**：
  - pluginlib 会用这个类型名去动态库中找到对应的类。
  - 它必须能和 `PLUGINLIB_EXPORT_CLASS` 中注册的类型匹配，否则加载失败。

---

### `base_class_type` 属性

- **示例值**：`my_package::MyPluginInterface`
- **含义**：
  - 插件类实现的 ** 基类（接口）** 的完整 C++ 类型名。
  - 必须与你在 `PLUGINLIB_EXPORT_CLASS` 注册的第二个参数完全一致。
- **作用**：
  - 告诉 pluginlib 这个插件属于哪个接口家族。
  - `ClassLoader<my_package::MyPluginInterface>` 只会加载 `base_class_type` 匹配的插件。

---

## 3. `<description>` 标签

- **示例值**：`示例插件`
- **含义**：
  - 插件的**说明文字**，纯文本，用于文档或调试。
- **作用**：
  - 不影响功能，只起描述作用。
  - 你可以用 `pluginlib::ClassLoader::getPluginInfo()` 获取这个描述。

---

## 4. 总结表格

| 标签 / 属性           | 示例值                             | 含义         | 作用                               |
| ----------------- | ------------------------------- | ---------- | -------------------------------- |
| `<library>`       | -                               | 动态库容器标签    | 包含一个或多个插件类                       |
| `path`            | `lib/libmy_plugin`              | 动态库相对路径    | 告诉 pluginlib 插件代码在哪              |
| `<class>`         | -                               | 单个插件类声明    | 描述一个插件的具体信息                      |
| `name`            | `my_package/MyPlugin`           | 插件的查找名称    | 用户在代码中用这个名字加载插件                  |
| `type`            | `my_package::MyPlugin`          | 插件的 C++ 类名 | 与 PLUGINLIB_EXPORT_CLASS 第一个参数对应 |
| `base_class_type` | `my_package::MyPluginInterface` | 插件实现的基类    | 与 PLUGINLIB_EXPORT_CLASS 第二个参数对应 |
| `<description>`   | `示例插件`                          | 插件说明文字     | 文档用，不影响运行                        |

**CMakeLists.txt 配置**：

```cmake
add_library(my_plugin src/my_plugin.cpp)
target_link_libraries(my_plugin ${catkin_LIBRARIES})

install(TARGETS my_plugin
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)

install(FILES my_plugin.xml
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
)
```

add_library(my_plugin src/my_plugin.cpp)

- **作用**：
  
  告诉 CMake 把 `src/my_plugin.cpp` 这个源文件编译成一个**动态链接库**（在 Linux 下是 `.so` 文件）。

- **参数解释**：
  
  - `my_plugin`：库的名字（CMake 会自动在 Linux 下生成 `libmy_plugin.so`）。
  - `src/my_plugin.cpp`：源文件路径。

- **注意**：
  
  - 插件必须编译成**共享库（shared library）**，因为 pluginlib 是通过 `dlopen()` 动态加载的。
  - CMake 默认会根据 `project()` 设置和 `add_library` 方式来决定是静态还是动态库，但在 ROS 中通常会在 `catkin_package()` 后默认生成共享库。

```cmake
target_link_libraries(my_plugin ${catkin_LIBRARIES})
```

- **作用**：
  
  把 ROS（catkin）依赖的库链接到你的插件库中。

- **参数解释**：
  
  - `my_plugin`：目标库名。
  - `${catkin_LIBRARIES}`：这是一个 CMake 变量，由 `find_package(catkin ...)` 自动填充，包含了你的 `package.xml` 中声明的所有依赖库路径。

- **为什么需要**：
  
  - 你的插件可能用到了 `ros/ros.h`、`pluginlib/class_list_macros.h` 等头文件对应的库。
  - 如果不链接，编译时可能会出现 undefined reference 错误。

```cmake
install(TARGETS my_plugin
  ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION}
  RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
```

**作用**：- 在 `catkin_make install` 或 `catkin build --install` 时，把编译好的库文件安装到 ROS 包的标准位置，这样运行时才能被找到。

- **各参数解释**：
  
  - `TARGETS my_plugin`：指定要安装的目标是我们刚才编译的 `my_plugin` 库。
  - `ARCHIVE DESTINATION ...`：静态库文件（`.a`）安装路径。
  - `LIBRARY DESTINATION ...`：动态库文件（`.so`）安装路径。
  - `RUNTIME DESTINATION ...`：可执行文件（Windows 下的 `.exe`）安装路径（Linux 下一般不用）。

- **ROS 路径变量含义**：
  
  - `${CATKIN_PACKAGE_LIB_DESTINATION}` → 安装到 `lib/<package_name>/`
  - `${CATKIN_PACKAGE_BIN_DESTINATION}` → 安装到 `lib/<package_name>/`（ROS1 中可执行文件一般放这里）
  - 这些路径是相对于 `CMAKE_INSTALL_PREFIX` 的，在 ROS 中通常是 `devel/lib` 或 `install/lib`。

```cmake
install(FILES my_plugin.xml
  DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION}
)
```

- **作用**：
  
  把插件的 XML 描述文件安装到 ROS 包的 `share` 目录中，这样 ROS 运行时可以找到它。

- **参数解释**：
  
  - `FILES my_plugin.xml`：指定要安装的文件。
  - `${CATKIN_PACKAGE_SHARE_DESTINATION}`：安装到 `share/<package_name>/` 目录。

- **为什么必须安装**：
  
  - pluginlib 在运行时会读取这个 XML 文件来找到插件动态库的路径和类信息。
  - 如果不安装，即使 `.so` 文件存在，ROS 也找不到插件。

**package.xml 声明**：

```xml
<export>
  <my_package plugin="${prefix}/my_plugin.xml"/>
</export>
```
