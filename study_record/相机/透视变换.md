透视变换

图像

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main() {
    // ---------------------- 步骤1：读取图像 ----------------------
    Mat src = imread("input.jpg"); // 替换为你的图像路径
    if (src.empty()) {
        cerr << "无法读取图像，请检查路径！" << endl;
        return -1;
    }

    // ---------------------- 步骤2：定义源点和目标点 ----------------------
    // 源点：原始图像中四边形的4个顶点（需按顺序：左上→右上→右下→左下）
    vector<Point2f> srcPoints;
    srcPoints.push_back(Point2f(100, 100));   // 示例坐标，需根据实际图像调整
    srcPoints.push_back(Point2f(400, 100));   // 右上
    srcPoints.push_back(Point2f(450, 300));   // 右下
    srcPoints.push_back(Point2f(150, 350));   // 左下

    // 目标点：变换后矩形的4个顶点（顺序需与源点一致）
    vector<Point2f> dstPoints;
    dstPoints.push_back(Point2f(0, 0));       // 左上（目标矩形左上角）
    dstPoints.push_back(Point2f(500, 0));     // 右上（目标矩形宽度500）
    dstPoints.push_back(Point2f(500, 400));   // 右下（目标矩形高度400）
    dstPoints.push_back(Point2f(0, 400));     // 左下

    // ---------------------- 步骤3：计算透视变换矩阵 ----------------------
    Mat perspectiveMatrix = getPerspectiveTransform(srcPoints, dstPoints);

    // ---------------------- 步骤4：应用透视变换 ----------------------
    Mat dst;
    warpPerspective(
        src, dst, 
        perspectiveMatrix, 
        Size(dstPoints[1].x, dstPoints[2].y), // 目标图像尺寸（宽=500，高=400）
        INTER_LINEAR,                         // 插值方式（双线性插值）
        BORDER_CONSTANT,                      // 边框填充方式
        Scalar(0, 0, 0)                       // 边框颜色（黑色）
    );

    // ---------------------- 步骤5：显示并保存结果 ----------------------
    imshow("原图", src);
    imshow("透视变换后", dst);
    waitKey(0); // 按任意键关闭窗口

    imwrite("output.jpg", dst); // 保存结果

    return 0;
}
```

点

```cpp
#include <opencv2/opencv.hpp>
using namespace cv;

int main() {
    // 假设已得到透视变换矩阵 perspectiveMatrix（3x3）

    // 待变换的单个点（示例）
    Point2f srcPt(100, 100);  // 替换为你的点坐标

    // 步骤1：将点存入 vector（即使只有一个点）
    vector<Point2f> srcPts;
    srcPts.push_back(srcPt);

    // 步骤2：调用 perspectiveTransform 计算变换后的点
    vector<Point2f> dstPts;
    perspectiveTransform(srcPts, dstPts);  // 结果存入 dstPts

    // 步骤3：获取变换后的点（dstPts[0] 即为结果）
    Point2f transformedPt = dstPts[0];

    // 输出结果
    printf("变换前: (%.2f, %.2f)\n", srcPt.x, srcPt.y);
    printf("变换后: (%.2f, %.2f)\n", transformedPt.x, transformedPt.y);

    return 0;
}
```

## $相机坐标系 = R * 世界坐标系 + T$

tvec=−R⋅Cworld

其中 Cworld​ 是相机在世界坐标系中的位置。

示例

```cpp
// 回调函数：处理接收到的 TF 消息
void tfCallback(const tf2_msgs::TFMessage::ConstPtr& msg)
{
    for (const auto& transform : msg->transforms)
    {
        if(transform.header.frame_id != "odom")
        {
            std::cout<< transform.header.frame_id<<std::endl;
            continue;
        }
        // 获取四元数
        geometry_msgs::Quaternion quat = transform.transform.rotation;

        // 使用 tf2 库将四元数转换为欧拉角
        tf2::Quaternion tf_quat;
        tf_quat.setX(quat.x);
        tf_quat.setY(quat.y);
        tf_quat.setZ(quat.z);
        tf_quat.setW(quat.w);

        // 转换为旋转矩阵，然后提取欧拉角
        tf2::Matrix3x3 mat(tf_quat);
        double roll, pitch, yaw;
        mat.getRPY(roll, pitch, yaw);  // 得到的是弧度值

        cv::Mat R = (cv::Mat_<double>(3,3) <<
            cos(yaw), 0, sin(yaw),
            0, 1, 0,
           -sin(yaw), 0, cos(yaw));
        cv::Mat R_inv;
        cv::Mat C_world = (cv::Mat_<double>(3,1) << -transform.transform.translation.y, 0.0, transform.transform.translation.x);
        cv::invert(R, R_inv);
        {
            std::lock_guard<std::mutex> lock(global._mtx_tf);
            cv::Rodrigues(R, global._rvec);
            global._tvec = - (R * C_world);
        }

        std::cout<< "yaw: "<< yaw <<std::endl;
        // double yaw_deg = yaw * 180.0 / M_PI;
        // float _x  = transform.transform.translation.x - 0.28*cos(yaw) + 0.28;
        // float _y = transform.transform.translation.y - 0.28*sin(yaw);

    }
}
```
