# Mid-360

## Point-Lio

新特性：

- ​**​不会因退化环境失效​**​（即在传感器退化场景下仍可正常工作）。

- ​**​高里程计输出频率​**​，支持 4k~8kHz（即每秒输出 4000~8000 次位姿估计结果）。

- ​**​对 IMU 饱和、剧烈振动及其他激进运动具有强鲁棒性​**​（测试中可应对高达 75 rad/s 的角速度）。

- ​**​无运动畸变​**​（即输出的位姿估计不受传感器运动导致的测量失真影响）。

- ​**​计算高效、鲁棒性强、通用性好​**​，适用于公开数据集及常规运动场景。

作为里程计模块，Point-LIO 可应用于多种自动驾驶任务（如轨迹规划、运动控制、环境感知），尤其适用于​**​高动态场景​**​（如存在剧烈振动、高线速度/角速度的情况）或​**​需要高频里程计输出与建图的任务​**​（如高频反馈控制、实时感知）。

### 重要说明：

​**​A. 请确保 IMU 与激光雷达（LiDAR）已同步​**​，这一点至关重要！

​**​B. 请获取您所用 IMU 的加速度计与陀螺仪的饱和值（即传感器量程上限），以及加速度计的单位，并据此修改配置文件（.yaml）中的相关参数​**​，包括 `satu_acc`（加速度饱和值）、`satu_gyro`（陀螺仪饱和值）、`acc_norm`（加速度单位相关参数）。此步骤非常重要！

​**​C. 若出现警告信息 “Failed to find match for field 'time'.”，表示您的 rosbag 文件中缺失了每个激光雷达点的时间戳​**​。这一点很关键，因为 Point-LIO 是基于每个激光雷达点的采样时间进行处理（逐点处理）。

​**​D. 若已提供 IMU 与激光雷达之间的外参（即两者相对位姿的标定结果），建议将配置参数 `extrinsic_est_en`设为 false（关闭外参在线估计功能）​**​。关于外参的初始标定方法，请参考我们的最新研究工作：《Robust and Online LiDAR-inertial Initialization》（鲁棒在线激光雷达-惯性初始化）。

​**​E. 若需要在不降采样（即不降低数据分辨率）的情况下实现高频率里程计输出，请将配置参数 `publish_odometry_without_downsample`设为 true​**​。此时终端窗口可能会弹出 tf 库的警告信息 “TF_REPEATED_DATA”（因两次里程计发布的时间间隔过小）。可通过以下命令抑制该警告（降低其输出频率至每 10 秒一次）：

**F. 若希望在不使用 IMU 的情况下运行 Point-LIO，请将配置参数 `imu_en`设为 false​**​，并在 yaml 文件中将 `gravity_init`设为 true（尽可能提供准确的初始重力值），同时保持 `use_imu_as_input`为 0（即不将 IMU 数据作为输入）。

### **1. Avia（傲览）​**​

- ​**​所属厂商​**​：大疆旗下Livox（览沃科技）。

- ​**​技术特点​**​：
  
  - ​**​扫描模式​**​：支持非重复扫描与重复扫描两种模式。非重复扫描覆盖视场更广，适合动态环境；重复扫描提升点云密度均匀性，适合高精度测绘

- 。

- ​**​探测性能​**​：最大探测距离190米（10%反射率），支持三回波模式，点云密度达24万点/秒，角度分辨率0.1°×0.1°

- 。

- ​**​应用场景​**​：电力巡检、林业测绘、智慧城市等

- - 。

- ​**​优势​**​：轻量化设计（498g）、远量程、高可靠性，价格较传统机械式雷达更低

- 。

---

### ​**​2. Horizon（浩界）​**​

- ​**​所属厂商​**​：Livox。

- ​**​技术特点​**​：
  
  - ​**​视场角​**​：水平70.4°×垂直77.2°，采用非重复扫描技术，覆盖范围随时间累积增加

- 。

- ​**​探测距离​**​：260米（10%反射率），支持三回波，点云密度达72万点/秒

- 。

- ​**​应用场景​**​：自动驾驶、机器人导航、泛测绘等

- - 。

- ​**​优势​**​：高性价比（价格仅为64线机械雷达的5%），适合大范围动态环境感知

- 。

---

### ​**​3. Ouster64​**​

- ​**​所属厂商​**​：美国Ouster公司。

- ​**​技术特点​**​：
  
  - ​**​扫描方式​**​：采用数字激光雷达技术，固态设计，无机械旋转部件。
  
  - ​**​探测性能​**​：最大探测距离200米，分辨率0.36°×0.36°，支持多回波和抗干扰能力

- 。

- ​**​应用场景​**​：自动驾驶、机器人、工业检测等

- - 。

- ​**​优势​**​：高可靠性、低维护成本，适合复杂工业环境

- 。

---

### ​**​4. Velody16（推测为Velodyne VLP-16）​**​

- ​**​所属厂商​**​：美国Velodyne公司。

- ​**​技术特点​**​：
  
  - ​**​扫描方式​**​：机械旋转式，16线激光发射器。
  
  - ​**​探测性能​**​：最大探测距离100米，水平视场角360°，垂直视场角30°，点云密度较低

- 。

- ​**​应用场景​**​：早期自动驾驶测试、无人机避障等

- - 。

- ​**​优势​**​：成本低、技术成熟，但逐渐被固态雷达替代

。

## 代码

### 启动雷达

[livox_ros_driver/README_CN.md at master · Livox-SDK/livox_ros_driver · GitHub](https://github.com/Livox-SDK/livox_ros_driver/blob/master/README_CN.md)

[Livox-SDK/README_CN.md at master · Livox-SDK/Livox-SDK · GitHub](https://github.com/Livox-SDK/Livox-SDK/blob/master/README_CN.md)

```xml
<launch>
    <arg name="lvx_file_path" default="livox_test.lvx"/>
    <arg name="bd_list" default="100000000000000"/>
    <arg name="xfer_format" default="0"/>
    <arg name="multi_topic" default="0"/>
    <arg name="data_src" default="0"/>
    <arg name="publish_freq" default="10.0"/>
    <arg name="output_type" default="0"/>
    <arg name="rviz_enable" default="true"/>
    <arg name="rosbag_enable" default="false"/>
    <arg name="cmdline_arg" default="$(arg bd_list)"/>
    <arg name="msg_frame_id" default="livox_frame"/>
    <arg name="lidar_bag" default="true"/>
    <arg name="imu_bag" default="true"/>

    <param name="xfer_format" value="$(arg xfer_format)"/>
    <param name="multi_topic" value="$(arg multi_topic)"/>
    <param name="data_src" value="$(arg data_src)"/>
    <param name="publish_freq" type="double" value="$(arg publish_freq)"/>
    <param name="output_data_type" value="$(arg output_type)"/>
    <param name="cmdline_str" type="string" value="$(arg bd_list)"/>
    <param name="cmdline_file_path" type="string" value="$(arg lvx_file_path)"/>
    <param name="user_config_path" type="string" value="$(find livox_ros_driver)/config/livox_lidar_config.json"/>    
    <param name="frame_id" type="string" value="$(arg msg_frame_id)"/>
    <param name="enable_lidar_bag" type="bool" value="$(arg lidar_bag)"/>
    <param name="enable_imu_bag" type="bool" value="$(arg imu_bag)"/>

    <node name="livox_lidar_publisher" pkg="livox_ros_driver"
          type="livox_ros_driver_node" required="true"
          output="screen" args="$(arg cmdline_arg)"/>

    <group if="$(arg rviz_enable)">
        <node name="rviz" pkg="rviz" type="rviz" respawn="true"
                args="-d $(find livox_ros_driver)/config/display_lidar_points.rviz"/>
    </group>

    <group if="$(arg rosbag_enable)">
        <node pkg="rosbag" type="record" name="record" output="screen"
                  args="-a"/>
    </group>

</launch>
```

以下是对该 ROS Launch 文件中​**​每个参数（`<arg>`和 `<param>`）及关键节点作用​**​的详细解释，主要围绕 Livox 激光雷达驱动的配置和功能展开：

### ​**​一、`<arg>`标签：启动参数（用户自定义输入）​**​

`<arg>`用于定义启动时可配置的参数，用户可通过命令行覆盖默认值，灵活调整驱动行为。

| 参数名             | 默认值                 | 作用                                                                                  |
| --------------- | ------------------- | ----------------------------------------------------------------------------------- |
| `lvx_file_path` | `"livox_test.lvx"`  | 指定要读取的 ​**​LVX 数据文件路径​**​（Livox 激光雷达专用的离线数据格式）。若 `data_src=0`（从文件读取），则使用此路径。        |
| `bd_list`       | `"100000000000000"` | ​**​设备广播码/多播组地址​**​（可能用于实时数据接收时的设备识别或多播通信）。若 `data_src=1`（实时硬件数据），此参数可能用于指定连接的设备。   |
| `xfer_format`   | `0`                 | ​**​数据传输格式​**​（0：默认二进制格式；其他值可能对应不同封装协议，需参考 Livox 驱动文档）。                             |
| `multi_topic`   | `0`                 | ​**​是否多主题发布​**​（0：所有点云合并为一个主题；1：按传感器类型拆分为多个主题，如激光雷达、IMU）。                           |
| `data_src`      | `0`                 | ​**​数据源类型​**​（0：从 LVX 文件读取离线数据；1：实时接收硬件（如 Livox 雷达）的 USB/网络数据）。                     |
| `publish_freq`  | `10.0`（Hz）          | ​**​数据发布频率​**​（限制点云数据的发布速率，避免过高频率导致系统负载过大）。                                         |
| `output_type`   | `0`                 | ​**​输出数据类型​**​（0：原始点云；1：经坐标变换后的点云；其他值可能对应过滤、降采样等处理后的数据，需参考驱动文档）。                    |
| `rviz_enable`   | `true`              | ​**​是否启用 RViz 可视化​**​（`true`时启动 RViz 并加载点云显示配置；`false`则不启动）。                        |
| `rosbag_enable` | `false`             | ​**​是否启用 rosbag 记录​**​（`true`时启动 `rosbag record`节点，记录所有话题数据到 `.bag`文件；`false`则不记录）。 |
| `cmdline_arg`   | `$(arg bd_list)`    | ​**​传递给驱动节点的命令行参数​**​（此处直接使用 `bd_list`的值，可能用于向 `livox_ros_driver_node`传递额外配置）。      |
| `msg_frame_id`  | `"livox_frame"`     | ​**​点云消息的坐标系 ID​**​（ROS 点云消息的 `frame_id`字段，用于坐标变换，需与 URDF 或 TF 树中的坐标系一致）。           |
| `lidar_bag`     | `true`              | ​**​是否记录激光雷达数据到 rosbag​**​（`true`时仅记录激光雷达点云；`false`则忽略）。                            |
| `imu_bag`       | `true`              | ​**​是否记录 IMU 数据到 rosbag​**​（`true`时仅记录 IMU 数据；`false`则忽略）。                          |

## MID360_config.json（以官方）

```json
{
  // 激光雷达全局概要信息，用于描述雷达的基础类型信息
  "lidar_summary_info" : {
    // 激光雷达类型编码（Livox内部定义的设备类型标识）
    // 不同lidar_type对应不同的硬件型号或功能特性，驱动根据此值适配通信协议和数据处理逻辑
    // MID360对应的类型编码为8（具体编码规则需参考Livox官方文档）
    "lidar_type": 8
  },

  // MID360激光雷达的专用配置节点，包含设备网络通信和主机交互的核心参数
  "MID360": {
    // 激光雷达（设备端）网络配置，定义设备主动向主机发送数据的通信端口
    "lidar_net_info" : {
      // 设备端命令/控制指令接收端口（主机通过此端口向雷达发送控制命令）
      "cmd_data_port": 56100,
      // 设备端消息推送端口（雷达主动向主机推送状态/告警等消息）
      "push_msg_port": 56200,
      // 设备端点云数据传输端口（雷达向主机发送激光点云数据的核心端口）
      "point_data_port": 56300,
      // 设备端IMU数据传输端口（雷达向主机发送惯性测量单元数据，如加速度、角速度）
      "imu_data_port": 56400,
      // 设备端日志数据传输端口（雷达向主机推送运行日志，通常用于调试）
      "log_data_port": 56500
    },

    // 主机（运行ROS的计算机）网络配置，定义主机接收雷达数据的本地接口
    "host_net_info" : {
      // 主机命令接收IP（雷达发送控制指令的目标IP，需与主机实际IP匹配）
      "cmd_data_ip" : "192.168.1.5",
      // 主机命令接收端口（与lidar_net_info.cmd_data_port需一致，避免端口冲突）
      "cmd_data_port": 56101,
      // 主机消息推送接收IP（雷达主动推送消息的目标IP）
      "push_msg_ip": "192.168.1.5",
      // 主机消息推送接收端口（与lidar_net_info.push_msg_port需一致）
      "push_msg_port": 56201,
      // 主机点云数据接收IP（雷达发送点云的目标IP）
      "point_data_ip": "192.168.1.5",
      // 主机点云数据接收端口（与lidar_net_info.point_data_port需一致）
      "point_data_port": 56301,
      // 主机IMU数据接收IP（雷达发送IMU数据的目标IP）
      "imu_data_ip" : "192.168.1.5",
      // 主机IMU数据接收端口（与lidar_net_info.imu_data_port需一致）
      "imu_data_port": 56401,
      // 主机日志数据接收IP（空字符串表示使用默认主机IP，或不启用日志接收）
      "log_data_ip" : "",
      // 主机日志数据接收端口（与lidar_net_info.log_data_port需一致）
      "log_data_port": 56501
    }
  },

  // 激光雷达参数配置列表（支持多雷达时扩展数组元素）
  "lidar_configs" : [
    {
      // 当前配置对应的雷达设备IP地址（需与雷达实际设置的IP匹配）
      "ip" : "192.168.1.12",
      // 点云数据类型编码（定义点云的格式/通道信息）
      // 常见值：1-标准XYZI格式（含坐标和强度）；其他值可能对应压缩格式或特殊编码
      "pcl_data_type" : 1,
      // 扫描模式配置（影响点云的扫描方式和覆盖范围）
      // 0-默认模式（如MID360的全视场360°扫描）；其他值可能对应特定模式（如ROI区域扫描）
      "pattern_mode" : 0,
      // 外参变换矩阵（将雷达本地坐标系转换为机器人/全局坐标系的参数）
      "extrinsic_parameter" : {
        "roll": 0.0,       // 横滚角（绕X轴旋转角度，单位：弧度）
        "pitch": 0.0,      // 俯仰角（绕Y轴旋转角度，单位：弧度）
        "yaw": 0.0,        // 偏航角（绕Z轴旋转角度，单位：弧度）
        "x": 0,            // 雷达本地坐标系原点在目标坐标系的X偏移（米）
        "y": 0,            // 雷达本地坐标系原点在目标坐标系的Y偏移（米）
        "z": 0             // 雷达本地坐标系原点在目标坐标系的Z偏移（米）
      }
    }
  ]
}
```

## rviz_MID360.launch

```xml
<launch>

    <!-- ==================== 用户可配置参数（启动时可自定义） ==================== -->
    <!-- LiDAR原始数据文件路径（LVX格式，Livox专有数据存储格式，可选，默认使用实时数据） -->
    <arg name="lvx_file_path" default="livox_test.lvx"/>
    <!-- 设备标识列表（可能用于多设备场景，数值为设备唯一标识，具体含义需参考驱动文档） -->    <arg name="bd_list" default="100000000000000"/>
    <!-- 数据传输格式编码（0-默认格式；其他值对应不同传输协议，影响数据解析方式） -->
    <arg name="xfer_format" default="0"/>
    <!-- 是否启用多主题发布（0-单主题合并发布；1-按传感器/通道分主题发布，适用于多LiDAR场景） -->
    <arg name="multi_topic" default="0"/>
    <!-- 数据源类型（0-实时数据（从LiDAR设备直接接收）；1-LVX文件回放（从本地文件读取历史数据）） -->
    <arg name="data_src" default="0"/>
    <!-- 数据发布频率（Hz，控制点云/IMU数据的发布速率，需与LiDAR实际输出频率匹配） -->
    <arg name="publish_freq" default="10.0"/>
    <!-- 输出数据类型编码（定义点云数据结构，如0-XYZI（坐标+强度）；1-XYZIR（含反射率）等） -->
    <arg name="output_type" default="0"/>
    <!-- 是否启用RViz可视化（true-启动RViz显示点云；false-不启动） -->
    <arg name="rviz_enable" default="true"/>
    <!-- 是否启用ROSBag录制（false-不录制；true-录制所有话题数据到Bag文件） -->
    <arg name="rosbag_enable" default="false"/>
    <!-- 传递给驱动节点的命令行参数（此处绑定bd_list，可能用于指定设备列表或其他运行时选项） -->
    <arg name="cmdline_arg" default="$(arg bd_list)"/>
    <!-- 点云数据的坐标系帧ID（ROS中用于坐标变换的标识，如"livox_frame"对应LiDAR的安装坐标系） -->
    <arg name="msg_frame_id" default="livox_frame"/>
    <!-- 是否将LiDAR点云数据记录到ROSBag（true-记录；false-不记录，优先级高于rosbag_enable全局开关） -->
    <arg name="lidar_bag" default="true"/>
    <!-- 是否将IMU数据记录到ROSBag（true-记录；false-不记录） -->
    <arg name="imu_bag" default="true"/>

    <!-- ==================== 将用户参数映射到ROS参数服务器 ==================== -->
    <!-- 数据传输格式参数（驱动节点读取此参数调整通信协议） -->
    <param name="xfer_format" value="$(arg xfer_format)"/>
    <!-- 多主题发布开关（驱动根据此值决定是否拆分数据主题） -->
    <param name="multi_topic" value="$(arg multi_topic)"/>
    <!-- 数据源类型（驱动根据此值选择实时接收或文件回放） -->
    <param name="data_src" value="$(arg data_src)"/>
    <!-- 数据发布频率（驱动按此频率推送数据，需与硬件能力匹配） -->
    <param name="publish_freq" type="double" value="$(arg publish_freq)"/>
    <!-- 输出数据类型（驱动按此类型封装点云数据） -->
    <param name="output_data_type" value="$(arg output_type)"/>
    <!-- 命令行参数字符串（驱动节点解析此字符串获取额外配置） -->
    <param name="cmdline_str" type="string" value="$(arg bd_list)"/>
    <!-- LVX文件路径（当data_src=1时，驱动从此路径读取历史数据） -->
    <param name="cmdline_file_path" type="string" value="$(arg lvx_file_path)"/>
    <!-- 用户配置文件路径（指定MID360的详细网络/外参配置，如IP、端口、坐标系变换等） -->
    <param name="user_config_path" type="string" value="$(find livox_ros_driver2)/config/MID360_config.json"/>
    <!-- 点云坐标系帧ID（驱动将点云数据的frame_id设为此值） -->
    <param name="frame_id" type="string" value="$(arg msg_frame_id)"/>
    <!-- LiDAR数据Bag记录开关（覆盖全局rosbag_enable，仅控制LiDAR数据） -->
    <param name="enable_lidar_bag" type="bool" value="$(arg lidar_bag)"/>
    <!-- IMU数据Bag记录开关（覆盖全局rosbag_enable，仅控制IMU数据） -->
    <param name="enable_imu_bag" type="bool" value="$(arg imu_bag)"/>

    <!-- ==================== 启动核心驱动节点 ==================== -->
    <!-- Livox LiDAR数据发布节点（必须启动，负责接收硬件数据并按配置发布ROS话题） -->
    <node name="livox_lidar_publisher2" pkg="livox_ros_driver2"
          type="livox_ros_driver2_node" required="true"
          output="screen" args="$(arg cmdline_arg)"/>
          <!-- 
              说明：
              - name：节点名称（唯一标识）
              - pkg：所属ROS包（livox_ros_driver2）
              - type：节点可执行文件（livox_ros_driver2_node）
              - required="true"：此节点为关键节点，若崩溃则整个launch终止
              - output="screen"：将节点标准输出/错误打印到终端（方便调试）
              - args：传递给节点的命令行参数（此处为bd_list，用于设备识别或配置）
          -->

    <!-- ==================== RViz可视化组（条件启动） ==================== -->
    <group if="$(arg rviz_enable)">
        <!-- 启动RViz可视化工具，加载预定义的点云显示配置 -->
        <node name="livox_rviz" pkg="rviz" type="rviz" respawn="true"
                args="-d $(find livox_ros_driver2)/config/display_point_cloud_ROS1.rviz"/>
                <!-- 
                    说明：
                    - group if：当rviz_enable为true时执行此组
                    - name：RViz节点名称
                    - pkg：RViz所属包（rviz）
                    - type：节点类型（rviz）
                    - respawn="true"：若RViz崩溃自动重启
                    - args：-d指定加载的RViz配置文件路径（包含点云显示插件配置）
                -->
    </group>

    <!-- ==================== ROSBag录制组（条件启动） ==================== -->
    <group if="$(arg rosbag_enable)">
        <!-- 启动ROSBag录制节点，记录所有ROS话题数据到Bag文件 -->
        <node pkg="rosbag" type="record" name="record" output="screen"
              args="-a"/>
              <!-- 
              说明：
              - group if：当rosbag_enable为true时执行此组
              - pkg：rosbag包
              - type：record节点（用于录制话题）
              - name：录制节点名称
              - output="screen"：输出录制日志到终端
              - args="-a"：-a参数表示录制所有活动的话题（若需指定话题可替换为-t或具体话题名）
              -->
    </group>

</launch>
```

## Lidar和IMU时间同步

在多传感器融合系统中（如自动驾驶的定位与感知），​**​LiDAR（低频，通常10-100Hz）与IMU（高频，通常100-1000Hz）的“同步”​**​并非指让两者的发送频率完全一致，而是​**​通过统一时间基准，将不同频率传感器的数据在“时间维度”上对齐​**​，确保同一物理时刻的传感器信息能够被正确关联和利用。这种同步是多传感器融合的核心前提，直接影响系统性能

## Point-LIO

在本研究中，我们通过两项关键创新技术——​**​逐点状态更新​**​与​**​随机过程增强的运动学模型​**​，有效解决了上述问题。具体而言，本工作的主要贡献如下：

- ​**​我们提出了一种逐点激光雷达-惯性里程计（LIO）框架​**​，该框架在激光雷达点的实际采样时刻对其进行融合，而无需将其累积为帧。通过消除点云累积过程，我们避免了帧内运动失真的问题，从而能够在接近点采样频率的速率下实现高频率的里程计输出与地图更新，这使得系统能够跟踪极高速运动；

- ​**​为了进一步提升系统带宽，使其超越惯性测量单元（IMU）的测量范围​**​，我们采用了一个​**​随机过程模型​**​[14]来对IMU测量值进行建模。随后，我们将该模型嵌入系统运动学中，并将IMU测量视为系统输出。这一​**​随机过程增强的运动学模型​**​使得即便在IMU出现饱和的情况下，系统仍能对包括角速度与线加速度在内的系统状态进行平滑估计；

- ​**​我们将这两项核心技术集成到一个完整的紧耦合LIO系统中，命名为 Point-LIO​**​。该系统采用​**​流形上的扩展卡尔曼滤波器（EKF）​**​，在每个激光雷达点或IMU数据的实际采样时刻对其融合并更新系统状态。通过充分利用系统的稀疏性与线性特性，该系统即使在低功耗的微小型飞行器（micro aerial vehicle, MAV）上基于​**​ARM（精简指令集计算机）架构的计算机​**​上运行，也能实现实时状态估计；
1. ​**​我们在使用一种视场角（FoV）极小的新兴固态激光雷达所采集的多种复杂真实场景数据上对该系统进行了测试​**​。实验结果表明，Point-LIO 能够有效补偿运动失真，实现​**​高频率的里程计输出（4–8 kHz）与高系统带宽（>150 Hz）​**​。该系统还能够在初始阶段之后，即使IMU测量值饱和，也能对极剧烈运动（角速度超过 75 rad/s）下的系统状态进行准确估计。

此外，通过在​**​12组来自多个公开激光雷达数据集的序列上开展详尽的基准对比实验​**​，结果表明：Point-LIO 在精度与效率方面与其他主流方法相比始终具有相当水平，同时所需的计算资源更少。最后，我们还展示了该系统在实际无人机（UAV）平台上的真实应用案例。

## 常见的warning

Point-LIO 是一款基于迭代最近点（ICP）的激光雷达惯性里程计（LIO）算法，其核心需要对激光雷达点云的时间戳（用于运动补偿）和扫描线信息（用于特征匹配）进行处理。因此，输入的点云必须包含以下两个字段：

- ​**​`time`字段​**​：表示每个点云点的时间戳（通常为相对于扫描起始时间的偏移量，单位多为秒或毫秒）。Point-LIO 需要利用该时间戳对点云进行运动畸变校正（因激光雷达扫描时机器人可能在运动）。
1. ​**​`ring`字段​**​：表示点所在的扫描线编号（即激光雷达的垂直方向线数索引，例如 32 线 LiDAR 的 `ring`值为 0~31）。Point-LIO 需要通过 `ring`识别同一扫描线的点，以进行扫描匹配（如相邻点云的关联）。

## void standard_pcl_cbk(const sensor_msgs::PointCloud2::ConstPtr &msg)

```cpp
// 定义LiDAR点云数据的回调函数，参数为ROS的传感器消息常量指针（点云格式为PointCloud2）
void standard_pcl_cbk(const sensor_msgs::PointCloud2::ConstPtr &msg) 
{
    // 尝试锁定互斥锁（当前被注释，可能用于保护共享缓冲区，防止多线程并发访问冲突）
    // mtx_buffer.lock();

    // 全局扫描计数器加1，记录已处理的LiDAR点云帧数
    scan_count ++;

    // 获取当前预处理的起始时间（使用OpenMP的高精度计时函数，单位：秒）
    double preprocess_start_time = omp_get_wtime();

    // 检查当前点云的时间戳是否小于上一次记录的LiDAR时间戳（时间回退现象）
    if (msg->header.stamp.toSec() < last_timestamp_lidar)
    {
        // 输出错误日志：检测到LiDAR时间回环，需要清空缓冲区
        ROS_ERROR("lidar loop back, clear buffer");

        // （注释掉的代码）收缩缓冲区内存（可能用于释放无效数据占用的内存）
        // lidar_buffer.shrink_to_fit();

        // （注释掉的代码）解锁互斥锁（若之前已锁定）
        // mtx_buffer.unlock();

        // （注释掉的代码）通知其他等待线程缓冲区更新（可能用于多线程同步）
        // sig_buffer.notify_all();

        // 时间回退时直接返回，不处理当前点云
        return;
    }

    // 更新最后一次有效的LiDAR时间戳为当前点云的时间戳（用于后续时间比较）
    last_timestamp_lidar = msg->header.stamp.toSec();

    // （注释掉的代码）自适应同步IMU与LiDAR时间差（条件：IMU与LiDAR时间差超过1秒且未初始化过时间差）
    // if (abs(last_timestamp_imu - last_timestamp_lidar) > 1.0 && !timediff_set_flg && !imu_deque.empty()) {
    //     timediff_set_flg = true;  // 标记时间差已初始化
    //     timediff_imu_wrt_lidar = last_timestamp_imu - last_timestamp_lidar;  // 记录IMU相对于LiDAR的时间偏移
    //     // 输出自适应同步的时间差日志
    //     printf("Self sync IMU and LiDAR, HARD time lag is %.10lf \n \n", timediff_imu_wrt_lidar);
    // }

    // 判断LiDAR类型是否为特定型号（VELO16、OUST64、HESAIxt32）且切帧初始化完成
    if ((lidar_type == VELO16 || lidar_type == OUST64 || lidar_type == HESAIxt32) && cut_frame_init) 
    {
        // 定义双端队列：存储处理后的点云指针和对应的时间戳
        deque<PointCloudXYZI::Ptr> ptr;
        deque<double> timestamp_lidar;

        // 调用预处理函数处理原始点云消息（切帧模式）
        // 参数：输入消息、点云队列、时间戳队列、切帧数量、扫描计数器
        p_pre->process_cut_frame_pcl2(msg, ptr, timestamp_lidar, cut_frame_num, scan_count);

        // 遍历处理后的点云队列，将数据存入全局缓冲区
        while (!ptr.empty() && !timestamp_lidar.empty()) 
        {
            // 将当前点云指针存入LiDAR缓冲区
            lidar_buffer.push_back(ptr.front());
            ptr.pop_front();  // 弹出队列头部元素

            // 将时间戳转换为秒单位（原单位可能为毫秒）并存入时间缓冲区
            time_buffer.push_back(timestamp_lidar.front() / double(1000));
            timestamp_lidar.pop_front();  // 弹出队列头部元素
        }
    }
    else  // 非特定型号LiDAR或切帧未初始化时的处理逻辑
    {
        // 创建新的点云对象（容量20000点，1个宽度维度），用于存储处理后的点云
        PointCloudXYZI::Ptr  ptr(new PointCloudXYZI(20000,1));

        // 调用预处理函数处理原始点云消息（非切帧模式）
        p_pre->process(msg, ptr);

        if (con_frame)  // 连续帧合并模式开启时
        {
            if (frame_ct == 0)  // 当前是连续帧的第1帧
            {
                // 记录当前点云的时间戳为连续帧的起始时间（用于后续时间戳校正）
                time_con = last_timestamp_lidar;  // 或直接使用msg->header.stamp.toSec()
            }

            if (frame_ct < 10)  // 连续帧计数小于10帧时（未达到合并阈值）
            {
                // 遍历当前点云的每个点，校正其曲率值（基于起始时间与当前帧的时间差）
                // 曲率通常用于表示点云的扫描顺序（如Velodyne的旋转角度），时间差转换为毫秒单位
                for (int i = 0; i < ptr->size(); i++)
                {
                    ptr->points[i].curvature += (last_timestamp_lidar - time_con) * 1000;
                    // 将校正后的点添加到连续帧临时点云ptr_con中
                    ptr_con->push_back(ptr->points[i]);
                }
                frame_ct ++;  // 连续帧计数加1
            }
            else  // 连续帧计数达到10帧（达到合并阈值）
            {
                // 创建新的点云对象，复制当前连续帧临时点云ptr_con的内容
                PointCloudXYZI::Ptr  ptr_con_i(new PointCloudXYZI(10000,1));
                *ptr_con_i = *ptr_con;

                // 将合并后的连续帧点云存入LiDAR缓冲区
                lidar_buffer.push_back(ptr_con_i);

                // 记录当前连续帧的起始时间到时间缓冲区
                time_buffer.push_back(time_con);

                // 清空临时连续帧点云，准备接收下一批数据
                ptr_con->clear();

                // 重置连续帧计数为0，开始新的一轮连续帧收集
                frame_ct = 0;
            }
        }
        else  // 连续帧合并模式关闭时
        { 
            // 若处理后的点云非空（避免存储空点云）
            if (ptr->points.size() > 0)
            {
                // 将当前点云直接存入LiDAR缓冲区（使用emplace_back原地构造，避免拷贝）
                lidar_buffer.emplace_back(ptr);

                // 将当前点云的时间戳存入时间缓冲区（使用消息头的时间戳）
                time_buffer.emplace_back(msg->header.stamp.toSec());
            }
        }
    }

    // 计算预处理阶段的总耗时（当前时间 - 预处理起始时间），并存储到绘图数组s_plot11的对应位置
    s_plot11[scan_count] = omp_get_wtime() - preprocess_start_time;

    // （注释掉的代码）解锁互斥锁（若之前已锁定）
    // mtx_buffer.unlock();

    // （注释掉的代码）通知其他等待线程缓冲区更新（可能用于多线程同步）
    // sig_buffer.notify_all();
}
```

## void standard_pcl_cbk(const sensor_msgs::PointCloud2::ConstPtr &msg)

```cpp
// 定义Livox LiDAR点云数据的回调函数，参数为Livox ROS驱动自定义消息类型的常量指针（消息格式为CustomMsg）
void livox_pcl_cbk(const livox_ros_driver::CustomMsg::ConstPtr &msg) 
{
    // 尝试锁定互斥锁（当前被注释，可能用于保护共享缓冲区，防止多线程并发访问冲突）
    // mtx_buffer.lock();

    // 获取当前预处理的起始时间（使用OpenMP的高精度计时函数，单位：秒），用于统计预处理耗时
    double preprocess_start_time = omp_get_wtime();

    // 全局扫描计数器加1，记录已处理的Livox LiDAR点云帧数
    scan_count ++;

    // 检查当前点云消息的时间戳是否小于上一次记录的LiDAR时间戳（检测时间回退异常）
    if (msg->header.stamp.toSec() < last_timestamp_lidar)
    {
        // 输出错误日志：检测到LiDAR时间回环，需要清空缓冲区以避免错误数据累积
        ROS_ERROR("lidar loop back, clear buffer");

        // （注释掉的代码）收缩缓冲区内存（可能用于释放无效数据占用的内存，但当前未启用）
        // lidar_buffer.shrink_to_fit();

        // （注释掉的代码）解锁互斥锁（若之前已锁定，当前未启用）
        // mtx_buffer.unlock();

        // （注释掉的代码）通知其他等待线程缓冲区更新（可能用于多线程同步，当前未启用）
        // sig_buffer.notify_all();

        // 时间回退时直接返回，不处理当前点云，避免异常数据干扰
        return;
    }

    // 更新最后一次有效的LiDAR时间戳为当前点云消息的时间戳（用于后续时间比较和同步逻辑）
    last_timestamp_lidar = msg->header.stamp.toSec();    

    // （注释掉的代码）自适应同步IMU与LiDAR时间差（条件：IMU与LiDAR时间差超过1秒且未初始化过时间差）
    // if (abs(last_timestamp_imu - last_timestamp_lidar) > 1.0 && !timediff_set_flg && !imu_deque.empty()) {
    //     timediff_set_flg = true;  // 标记时间差已初始化
    //     timediff_imu_wrt_lidar = last_timestamp_imu - last_timestamp_lidar;  // 记录IMU相对于LiDAR的时间偏移量
    //     // 输出自适应同步得到的时间差日志（当前未启用）
    //     printf("Self sync IMU and LiDAR, HARD time lag is %.10lf \n \n", timediff_imu_wrt_lidar);
    // }

    // 判断是否已初始化切帧模式（cut_frame_init为true时启用切帧处理逻辑）
    if (cut_frame_init) 
    {
        // 定义双端队列：存储处理后的点云指针（PointCloudXYZI::Ptr）和对应的原始时间戳（单位可能为毫秒）
        deque<PointCloudXYZI::Ptr> ptr;
        deque<double> timestamp_lidar;

        // 调用预处理函数处理Livox原始消息（切帧模式）
        // 参数：输入消息（CustomMsg类型）、点云队列、时间戳队列、切帧数量、扫描计数器
        p_pre->process_cut_frame_livox(msg, ptr, timestamp_lidar, cut_frame_num, scan_count);

        // 遍历处理后的点云队列和对应的时间戳队列（确保两者非空时继续处理）
        while (!ptr.empty() && !timestamp_lidar.empty()) 
        {
            // 将当前点云指针存入全局LiDAR缓冲区（lidar_buffer），用于后续点云拼接或算法处理
            lidar_buffer.push_back(ptr.front());
            ptr.pop_front();  // 弹出队列头部元素，处理下一个点云

            // 将时间戳转换为秒单位（原单位可能为毫秒）并存入时间缓冲区（time_buffer）
            time_buffer.push_back(timestamp_lidar.front() / double(1000));
            timestamp_lidar.pop_front();  // 弹出队列头部元素，与点云一一对应
        }
    }
    else  // 未启用切帧模式时的处理逻辑
    {
        // 创建新的点云对象（容量10000点，1个宽度维度），用于存储预处理后的点云数据
        PointCloudXYZI::Ptr  ptr(new PointCloudXYZI(10000,1));

        // 调用预处理函数处理原始Livox消息（非切帧模式）
        p_pre->process(msg, ptr); 

        if (con_frame)  // 连续帧合并模式开启时（con_frame为true）
        {
            if (frame_ct == 0)  // 当前是连续帧合并的第1帧（初始化阶段）
            {
                // 记录当前点云的时间戳为连续帧的起始时间（用于后续时间戳校正）
                time_con = last_timestamp_lidar;  // 或直接使用msg->header.stamp.toSec()（当前注释了后者）
            }

            if (frame_ct < 10)  // 连续帧计数小于10帧时（未达到预设的合并阈值）
            {
                // 遍历当前点云的每个点，校正其曲率值（基于起始时间与当前帧的时间差）
                // 曲率（curvature）通常用于表示点云的扫描顺序（如Livox的旋转角度或扫描线顺序），时间差转换为毫秒单位累加
                for (int i = 0; i < ptr->size(); i++)
                {
                    ptr->points[i].curvature += (last_timestamp_lidar - time_con) * 1000;
                    // 将校正后的点添加到连续帧临时缓存点云（ptr_con）中，累积多帧数据
                    ptr_con->push_back(ptr->points[i]);
                }
                frame_ct ++;  // 连续帧计数加1，继续累积数据
            }
            else  // 连续帧计数达到10帧（达到合并阈值，触发合并操作）
            {
                // 创建新的点云对象，复制当前连续帧临时缓存点云（ptr_con）的内容
                PointCloudXYZI::Ptr  ptr_con_i(new PointCloudXYZI(10000,1));
                *ptr_con_i = *ptr_con;  // 复制点云数据（深拷贝）

                // 将合并后的连续帧点云存入全局LiDAR缓冲区（lidar_buffer），作为一帧完整数据
                lidar_buffer.push_back(ptr_con_i);

                // 记录当前连续帧的起始时间到时间缓冲区（time_buffer），与合并后的点云一一对应
                time_buffer.push_back(time_con);

                // 清空临时缓存点云（ptr_con），释放内存并准备接收下一批连续帧数据
                ptr_con->clear();

                // 重置连续帧计数为0，开始新的一轮连续帧累积
                frame_ct = 0;
            }
        }
        else  // 连续帧合并模式关闭时（con_frame为false）
        { 
            // 检查预处理后的点云是否非空（避免存储无效的空点云）
            if (ptr->points.size() > 0)
            {
                // 将当前点云直接存入全局LiDAR缓冲区（lidar_buffer），使用emplace_back原地构造避免拷贝开销
                lidar_buffer.emplace_back(ptr);

                // 将当前点云消息的时间戳（转换为秒）存入时间缓冲区（time_buffer），与点云一一对应
                time_buffer.emplace_back(msg->header.stamp.toSec());
            }
        }
    }

    // 计算预处理阶段的总耗时（当前时间 - 预处理起始时间），并存储到绘图数组s_plot11的对应位置（按扫描计数器索引）
    s_plot11[scan_count] = omp_get_wtime() - preprocess_start_time;

    // （注释掉的代码）解锁互斥锁（若之前已锁定，当前未启用）
    // mtx_buffer.unlock();

    // （注释掉的代码）通知其他等待线程缓冲区更新（可能用于多线程同步，当前未启用）
    // sig_buffer.notify_all();
}
```

## void Preprocess::process(const sensor_msgs::PointCloud2::ConstPtr &msg, PointCloudXYZI::Ptr &pcl_out)

```cpp
// 定义Preprocess类的成员函数process，用于预处理激光雷达点云数据
// 参数说明：
//   msg: 输入的ROS点云消息（类型为sensor_msgs::PointCloud2的常量指针）
//   pcl_out: 输出的点云数据（类型为PointCloudXYZI的智能指针，用于存储处理后的点云）
void Preprocess::process(const sensor_msgs::PointCloud2::ConstPtr &msg, PointCloudXYZI::Ptr &pcl_out)
{
  // 根据时间单位（time_unit）设置时间戳的缩放因子（time_unit_scale）
  // 该缩放因子用于将原始点云中的时间戳转换为统一的目标时间单位（如毫秒）
  switch (time_unit)
  {
    case SEC:       // 时间单位为秒（Seconds）
      time_unit_scale = 1.e3f;  // 缩放因子为1000（例如：原始时间戳单位为毫秒时，需乘以1000转换为秒？或反之，具体需结合数据格式）
      break;
    case MS:        // 时间单位为毫秒（Milliseconds）
      time_unit_scale = 1.f;    // 缩放因子为1（无需转换，原始时间戳已为毫秒）
      break;
    case US:        // 时间单位为微秒（Microseconds）
      time_unit_scale = 1.e-3f; // 缩放因子为0.001（例如：将微秒转换为毫秒需除以1000，即乘以0.001）
      break;
    case NS:        // 时间单位为纳秒（Nanoseconds）
      time_unit_scale = 1.e-6f; // 缩放因子为0.000001（例如：将纳秒转换为毫秒需除以1e6，即乘以0.000001）
      break;
    default:        // 未知时间单位（默认情况）
      time_unit_scale = 1.f;    // 使用默认缩放因子1（视为毫秒）
      break;
  }

  // 根据激光雷达类型（lidar_type）调用对应的点云解析处理函数
  switch (lidar_type)
  {
  case OUST64:      // 激光雷达类型为Ouster OS0/OS1/OS2（64线）
    oust64_handler(msg);  // 调用Ouster 64线激光雷达的点云处理函数（解析原始消息并填充点云数据）
    break;

  case VELO16:      // 激光雷达类型为Velodyne VLP-16（16线）
    velodyne_handler(msg);  // 调用Velodyne 16线激光雷达的点云处理函数
    break;

  case HESAIxt32:   // 激光雷达类型为速腾聚创Puck Hi-Puck（32线，型号可能为XT32）
    hesai_handler(msg);     // 调用速腾聚创32线激光雷达的点云处理函数
    break;

  default:          // 未知激光雷达类型
    printf("Error LiDAR Type");  // 打印错误提示信息（未处理异常，可能导致后续逻辑使用未初始化数据）
    break;
  }
  *pcl_out = pl_surf;  // 将类成员变量pl_surf（处理后的点云数据）赋值给输出参数pcl_out，完成输出
}
```

## 是否开启​**​连续帧合并**

### **一、核心概念：连续帧合并的本质​**​

连续帧合并指在处理LiDAR点云时，不直接对单帧点云单独处理，而是将相邻多帧（如2-5帧）的点云在时间同步、空间配准后合并为一个​**​增广点云​**​，再与IMU数据进行融合。其目的是通过增加点云的信息量（密度、覆盖范围）提升匹配精度，但需权衡计算成本和延迟。

### ​**​二、开启 vs 关闭连续帧合并的关键区别​**​

| ​**​对比维度​**​     | ​**​关闭连续帧合并（逐帧处理）​**​         | ​**​开启连续帧合并（多帧融合）​**​            |
| ---------------- | ----------------------------- | -------------------------------- |
| ​**​点云时间跨度​**​   | 单帧时间跨度（通常50-100ms，取决于LiDAR频率） | 多帧累积时间跨度（如200-500ms，取决于合并帧数）     |
| ​**​点云密度与信息量​**​ | 单帧点云密度低，覆盖区域小                 | 合并后点云密度更高，覆盖区域更大（空间扩展+时间累积）      |
| ​**​计算复杂度​**​    | 低（处理单帧点云，计算量小）                | 高（需合并多帧点云，配准与去重耗时增加）             |
| ​**​处理延迟​**​     | 低（实时性强，延迟等于单帧处理时间）            | 高（延迟等于多帧累积时间+处理时间）               |
| ​**​动态场景适应性​**​  | 对动态物体敏感（单帧可能包含更多动态点）          | 可能因多帧融合放大动态点干扰（需额外滤波）            |
| ​**​IMU预积分窗口​**​ | 短（仅覆盖单帧LiDAR时间间隔内的IMU数据）      | 长（覆盖多帧LiDAR时间间隔内的IMU数据，累积误差可能增大） |

 **注意：这里 Mid-360 的时间戳格式为 64 位无符号整数，单位为 ns。**

```python
# Livox publish pointcloud msg format.

std_msgs/Header header    # ROS standard message header
uint64 timebase           # The time of first point
uint32 point_num          # Total number of pointclouds
uint8  lidar_id           # Lidar device id number
uint8[3]  rsvd            # Reserved use
CustomPoint[] points      # Pointcloud data
```

## launch文件

### 1. `<arg name="rviz" default="true" />`

- 作用：定义一个 ROS 参数（参数名`rviz`），用于控制是否启动 RViz（ROS 的可视化工具）。
- 含义：`default="true"`表示默认值为`true`（通常后续会根据该参数决定是否启动 RViz 节点，此处仅定义参数，未直接启动）。

### 2. `<node pkg="point_lio" type="pointlio_mapping" name="laserMapping" output="screen">`

- 作用：启动一个 ROS 节点，是整个配置的核心容器。
- 各属性含义：
  - `pkg="point_lio"`：指定节点所属的功能包为`point_lio`（激光雷达 - IMU 融合建图的功能包）。
  - `type="pointlio_mapping"`：指定节点的可执行文件名称（编译后生成的二进制文件）。
  - `name="laserMapping"`：指定节点运行时的名称（用于 ROS 节点管理器识别，可自定义）。
  - `output="screen"`：指定节点的日志输出到终端屏幕（方便实时查看运行信息）。

### 3. `<rosparam command="load" file="$(find point_lio)/config/mid360.yaml" />`

- 作用：将外部参数文件加载到 ROS 参数服务器，供节点读取。
- 含义：
  - `command="load"`：执行 “加载” 操作。
  - `file="$(find point_lio)/config/mid360.yaml"`：指定加载的参数文件路径。`$(find point_lio)`是 ROS 的路径查找语法，会自动定位`point_lio`功能包的路径，然后加载其`config`目录下的`mid360.yaml`文件（即你之前看到的传感器配置、融合参数等）。

### 4. `<param name="use_imu_as_input" type="bool" value="0"/>`

- 作用：设置是否使用 IMU 数据作为`Point-LIO`算法的输入。
- 含义：
  - `type="bool"`：参数类型为布尔值。
  - `value="0"`：值为`0`（即`false`），表示不使用 IMU 数据作为输入；注释提到 “改为 1（`true`）则使用 IMU”。

### 5. `<param name="prop_at_freq_of_imu" type="bool" value="1"/>`

- 作用：设置是否以 IMU 的频率进行状态传播（SLAM 中 “状态预测” 的步骤）。
- 含义：
  - `value="1"`（`true`）：启用，即系统会按照 IMU 的采样频率（如 200Hz）更新机器人的位姿预测（比激光雷达频率更高，可提升动态场景下的平滑性）。

### 6. `<param name="check_satu" type="bool" value="1"/>`

- 作用：设置是否检查 IMU 数据的饱和状态。
- 含义：
  - `check_satu`是 “check saturation” 的缩写，IMU 传感器有测量范围限制（如加速度计最大量程 ±16g），超过范围会 “饱和”（输出固定值）。
  - `value="1"`（`true`）：启用检查，系统会过滤或修正饱和的 IMU 数据，避免错误输入影响融合结果。

### 7. `<param name="init_map_size" type="int" value="10"/>`

- 作用：设置初始地图的大小（通常指体素地图的初始尺寸）。
- 含义：`value="10"`可能表示初始地图在 xyz 轴方向的范围为 ±10 米（或体素网格的初始分辨率相关参数），用于初始化建图的空间范围。

### 8. `<param name="point_filter_num" type="int" value="3"/>`

- 作用：设置点云降采样的步长（保留点数的间隔）。
- 含义：`value="3"`表示每 3 个点保留 1 个（如原始点云有 9 个点，过滤后保留 3 个），用于减少点云数量、降低计算量；注释中提到可选 1（保留所有点）或 3（更激进的降采样）。

### 9. `<param name="space_down_sample" type="bool" value="1" />`

- 作用：设置是否启用空间降采样（基于空间分布的点云精简）。
- 含义：`value="1"`（`true`）：启用，通过体素网格等算法，在空间上均匀保留点云（而非简单按顺序间隔保留），在减少点数的同时尽量保留空间结构。

### 10. `<param name="filter_size_surf" type="double" value="0.5" />`

- 作用：设置 “表面特征点” 的降采样体素大小。
- 含义：`value="0.5"`（单位：米），表示对提取的表面特征点（如地面、墙面等平面点）使用 0.5 米的体素网格进行降采样 —— 每个 0.5 米 ×0.5 米 ×0.5 米的立方体中只保留一个点，平衡精度和计算量。

### 11. `<param name="filter_size_map" type="double" value="0.5" />`

- 作用：设置 “地图点云” 的降采样体素大小。
- 含义：`value="0.5"`（单位：米），表示构建全局地图时，对所有地图点使用 0.5 米的体素网格降采样，控制地图的总点数（避免地图过大导致内存溢出）。

### 12. `<param name="ivox_nearby_type" type="int" value="6" />`

- 作用：设置体素网格（iVox）中 “邻近点查找” 的模式（范围或方向）。
- 含义：`value="6"`是枚举值，可能对应 “6 个方向”（xyz 轴正负方向）的邻域搜索，用于在点云匹配时查找周围体素中的点，影响特征匹配的范围和精度（不同数值对应不同的邻域定义）。

### 13. `<param name="runtime_pos_log_enable" type="bool" value="0" />`

- 作用：设置是否启用运行时的位置日志记录。
- 含义：`value="0"`（`false`）：禁用，不记录机器人的实时位姿；注释提到改为 1（`true`）则启用，通常用于调试（记录轨迹到文件，后续分析定位精度）。

#### **等效线数（时间积分后）**

- Mid-360 采用**非重复扫描技术**，其激光束的扫描轨迹会随时间动态变化，而非传统机械式雷达的固定扫描线。
- 通过**多帧点云累积**（例如 5 秒内的扫描数据），其点云密度可等效于**32 线雷达**的效果。
- 这种设计的优势在于：
  - **单帧稀疏**：适合快速定位和障碍物检测。
  - **多帧稠密**：适合高精度地图构建（SLAM）。

### **2. 官方参数中的 32 线指什么？**

- 官方文档中提到的 “32 线” 通常是指**等效线数**，而非硬件线数。
- 例如，Livox 在宣传中强调 Mid-360 通过时间积分实现 “等效高线数”，但并未明确说明硬件线数为 4。
- 这种表述方式可能是为了与传统机械式雷达的线数标准对齐，便于用户理解其点云密度性能。

### **3. 为什么点云数据中`line`字段只有 0 到 3？**

- **硬件限制**：Mid-360 的物理激光发射器只有 4 个，每个激光线对应一个固定的垂直角度。
- **数据格式设计**：在 ROS 的`PointCloud2`消息中，`line`字段直接反映硬件线数（0 到 3），而非等效线数。
- **动态扫描的隐藏细节**：尽管硬件线数少，但通过非重复扫描技术，Mid-360 的激光束会覆盖更广泛的垂直角度范围，从而在长时间累积后形成高密度点云。
